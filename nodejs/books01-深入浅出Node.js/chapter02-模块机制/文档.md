## CommonJS规范
commonjs规范希望JavaScript能够在任何地方运行，是JavaScript规范中的重要里程碑

### CommonJs的出发点
- Html5规范主要发生在前端， 后端JavaScript规范却远远落后，对于javascript自身而言，他的规范依旧是薄弱的，有以下缺陷
````
-没有模块系统
-标准库较少
-没有标准接口
-缺少包管理系统
````
CommonJS规范的提出，主要是为了弥补当前Javascript没有标准的缺陷，以达到像python，ruby和java具备开发大型应用的基础能力，而不停留在小脚本程序的阶段。
期望Commonjs API写出的应用可以具备跨宿主环境的执行能力，这样不仅可以利用javascript开发富客户端应用，而且还可以编写如下应用：
````
- 服务端javascript应用
- 命令行工具
- 桌面图形界面应用程序
- 混合应用
````

- 规范依旧时草案，但已初见成效，规范包含-模块，二进制，Buffer,字符集编码，I/O流，进程环境，文件系统，套接字，单元测试，web服务器网关接口，包管理等

- Node以一种较成熟的姿态出现，离不开CommonJs规范的影响

### Commonjs的模块规范
- 模块引用
var math = require('math')
require()方法引入一个模块API
- 模块定义
上下文提供了exports对象用于导出当前的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个module对象，它代表模块本身，而exports是module属性。在Node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出模式。
````
math.js
exports.add = function(){
    ....
}
````

另一个文件中，我们通过require()方法引入模块后， 就能调用定义的属性或者方法了：
````
var math = require('math')
exports.increment = function(val){
    return math.add(val, 1)
}
````
3-模块标识
- 传递给require()方法的参数，必须是符合小驼峰命名的的字符串，或者以..开头的相对路径，可以不带后缀.js

### Node的模块实现
- Node并非完全按照规范实现，而对模块进行了一定的取舍，同时也增加了少许自身需要的特性。
> 在Node中引入模块，需要经历三个步奏
> 1-路径分析
> 2-文件定位
> 3-编译执行
- 模块分为两类-核心模块(Node自带的)和用户编写的模块(文件模块)
>核心模块在Node源代码编译过程中，编译进了二进制文件。
>文件模块则是运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢

- 优先从缓存加载
> 浏览器仅仅是缓存文件，而Node缓存的是编译和执行之后的对象
> 不论是核心模块还是文件模块，require()方法对相同模块的二次加载都采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查

- 路径分析和文件定位
1-模块标识符分析
- 核心模块(http, fs, path)，相对和绝对路径模块，非路径形式的文件模块，如connect模块
- 非路径形式的模块查找最耗时，当前文件路径越深越耗时

2-文件定位
- 文件扩展名分析
> require()在分析标识符的过程中，会出现标识符中不出现文件扩展名的情况。这种情况下，Node会按.js/.json/.node的次序补足扩展名，依次尝试。在尝试的过程中，需要利用fs模块同步阻塞式地判断文件是否存在。因为Node是单线程的，所以这里是一个会引起性能问题的地方。解决诀窍：1-.node和.json在标识符上带上扩展名； 2-同步配合缓存，可以大幅度缓解Node单线程中阻塞式调用的缺陷

- 目录分析和包
> require()查找到是一个目录，将目录当做包处理-查找package.json,main属性文件错误或不存在package.json->将index当做默认文件名，index.js/index.json/index.node依次查找

- 模块编译
> 在Node中，每个文件模块都是一个对象，它的定义如下：
````
function Module(id, parent) { 
    this.id = id;
    this.exports = {}; 
    this.parent = parent;
    if (parent && parent.children) {
        parent.children.push(this);
    }
    this.filename = null; this.loaded = false; this.children = [];
}
````

> 定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译，不同的文件扩展名，载入方法不同
````
1-.js文件，通过fs模块同步读取文件后编译执行
2-.node文件，c/c++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件
3-.json文件，通过fs同步读取文件后，用JSON.parse()解析返回结果
4-其余扩展名，都被当做.js载入
````

- 每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次载入的性能:
> 根据不同的文件扩展名，Node会调用不同的读取方式，如.json文件调用如下：
````
// Native extension for .json
Module._extensions['.json'] = function(module, filename) {
    var content = NativeModule.require('fs').readFileSync(filename, 'utf8'); 
    try {
        module.exports = JSON.parse(stripBOM(content));
    } catch (err) {
        err.message = filename + ': ' + err.message; throw err;
    } 
};
````
> javascript模块的编译
事实上，在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加了
(function (exports, require, module, __filename, __dirname) {\n，在尾部添加了\n});。
示例如下：
````
(function (exports, require, module, __filename, __dirname) 
{ var math = require('math');
    exports.area = function (radius) {
        return Math.PI * radius * radius; 
    };
 });
 ````
 这样每个模块之间都进行了作用域隔离。包装之后的代码会通过vm原生模块的
runInThisContext()方法执行(类似eval，只是具有明确上下文，不污染全局)，返回一个具体的function对象。最后，将当前模块对象的exports属性、require()方法、module(模块对象自身)， 以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。至此，require、exports、module的流程已经完整，这就是Node对CommonJS模块的实现。

exports和module.exports-exports形参形式传入，不能改变外面作用域的值，请赋值给module.exports


> c/c++模块编译
.node的模块文件并不需要编译，因为它是编写C/C++模块之后编译生成的，所以这里只有加载和执行的过程。在执行的过程中，模块的exports对象与.node模块产生联系，然后返回给调用者

> JSON文件的编译
fs->json.parse()->module.exports


- 核心模块
>  核心模块其实分为C/C++编写的和JavaScript编写的两部分，其中C/C++文件存放在Node项目的src目录下， JavaScript文件存放在lib目录下
> javascript核心模块的编译过程
javascript(v8:js2c.py)=>c/c++




