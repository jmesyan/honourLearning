## CommonJS规范
commonjs规范希望JavaScript能够在任何地方运行，是JavaScript规范中的重要里程碑

### CommonJs的出发点
- Html5规范主要发生在前端， 后端JavaScript规范却远远落后，对于javascript自身而言，他的规范依旧是薄弱的，有以下缺陷
````
-没有模块系统
-标准库较少
-没有标准接口
-缺少包管理系统
````
CommonJS规范的提出，主要是为了弥补当前Javascript没有标准的缺陷，以达到像python，ruby和java具备开发大型应用的基础能力，而不停留在小脚本程序的阶段。
期望Commonjs API写出的应用可以具备跨宿主环境的执行能力，这样不仅可以利用javascript开发富客户端应用，而且还可以编写如下应用：
````
- 服务端javascript应用
- 命令行工具
- 桌面图形界面应用程序
- 混合应用
````

- 规范依旧时草案，但已初见成效，规范包含-模块，二进制，Buffer,字符集编码，I/O流，进程环境，文件系统，套接字，单元测试，web服务器网关接口，包管理等

- Node以一种较成熟的姿态出现，离不开CommonJs规范的影响

### Commonjs的模块规范
- 模块引用
var math = require('math')
require()方法引入一个模块API
- 模块定义
上下文提供了exports对象用于导出当前的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个module对象，它代表模块本身，而exports是module属性。在Node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出模式。
````
math.js
exports.add = function(){
    ....
}
````

另一个文件中，我们通过require()方法引入模块后， 就能调用定义的属性或者方法了：
````
var math = require('math')
exports.increment = function(val){
    return math.add(val, 1)
}
````
3-模块标识
- 传递给require()方法的参数，必须是符合小驼峰命名的的字符串，或者以..开头的相对路径，可以不带后缀.js

### Node的模块实现
- Node并非完全按照规范实现，而对模块进行了一定的取舍，同时也增加了少许自身需要的特性。
> 在Node中引入模块，需要经历三个步奏
> 1-路径分析
> 2-文件定位
> 3-编译执行
- 模块分为两类-核心模块(Node自带的)和用户编写的模块(文件模块)
>核心模块在Node源代码编译过程中，编译进了二进制文件。
>文件模块则是运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢

